<!doctype html><html lang=en-us><head><title>Writing a ray tracer for the web</title><meta charset=utf-8><meta name=generator content="Hugo 0.61.0"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Kevin Masson"><meta name=description content="Major issues I encountered while making a toy ray tracer using compute shaders for the web."><link rel=stylesheet href=https://oktomus.com/style.d899c61eeba148ddeceea1b6fb05ce4aff2a5a15dbb5d294f3a9bd0e2ef734d1.css><link rel=stylesheet href=https://oktomus.com/sourcesanspro.976c714211e70394d35449e7ce2aee72b91cbf727b752cfb6a9c52bbc22c00fa.css><link rel=stylesheet href=https://oktomus.com/sourcecodepro.5dad8ddf281225439c9ef9a8ed92baf168af538c41d755c1fe26cc869ed0e6f3.css><meta name=twitter:card content="summary"><meta name=twitter:title content="Writing a ray tracer for the web"><meta name=twitter:description content="Major issues I encountered while making a toy ray tracer using compute shaders for the web."><meta property="og:title" content="Writing a ray tracer for the web"><meta property="og:description" content="Major issues I encountered while making a toy ray tracer using compute shaders for the web."><meta property="og:type" content="article"><meta property="og:url" content="https://oktomus.com/posts/2020/ray-tracer-with-webgl-compute/"><meta property="article:published_time" content="2020-01-13T00:00:00+00:00"><meta property="article:modified_time" content="2020-01-13T00:00:00+00:00"></head><body><header class=app-header><a href=https://oktomus.com/><img width=100 height=100 class=app-header-avatar src=/avatar.jpg alt="Kevin Masson"></a><h1><a href=https://oktomus.com/>oktomus</a></h1><p>Makes 3D softwares and photography while eating noodles.</p><div class=app-header-social><a target=_blank href=https://github.com/oktomus rel="noreferrer noopener" title=Github><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77a5.44 5.44.0 00-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a target=_blank href=https://twitter.com/oktomus rel="noreferrer noopener" title=Twitter><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a><a target=_blank href=mailto:hi@oktomus.com rel="noreferrer noopener" title=hi@oktomus.com><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-mail"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></a><a target=_blank href=https://www.linkedin.com/in/oktomus/ rel="noreferrer noopener" title=LinkedIn><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-linkedin"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a><a target=_blank href=https://www.instagram.com/oktomus/ rel="noreferrer noopener" title=Instagram><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-instagram"><rect x="2" y="2" width="20" height="20" rx="5" ry="5"/><path d="M16 11.37A4 4 0 1112.63 8 4 4 0 0116 11.37z"/><line x1="17.5" y1="6.5" x2="17.5" y2="6.5"/></svg></a><a target=_blank href=https://500px.com/oktomus rel="noreferrer noopener" title=500px><svg fill="currentcolor" width="48" id="svg2" height="24" viewBox="0 0 666.66669 166.13333"><g transform="matrix(1.3333333,0,0,-1.3333333,0,166.13333)" id="g10"><g transform="scale(0.1)" id="g12"><path id="path14" style="fill-opacity:1;fill-rule:nonzero;stroke:none" d="m4761.93 915.121 226.03 226.029c8.2 8.21 27.42 27.46-11.48 67.51-16.68 17.18-31.89 25.95-45.19 26.05h-.24c-11.45.0-19.17-6.14-25.21-12.17L4679.28 995.977 4453.09 1223.56c-18.28 18.3-39.69 14.01-67.29-13.55-28.07-28.22-32.66-49.89-14.45-68.2l226.22-227.564-221.56-221.57-1.58-1.547c-5.39-5.227-13.53-13.113-13.64-25.973-.1-13.261 8.73-28.879 26.26-46.414 14.8-14.812 28.82-22.316 41.7-22.316h.01c14.51.012 23.78 9.308 29.02 14.543l222.4 222.41 227.42-227.449c2.87-2.86 10.88-9.457 23.74-9.457h.46c14.38.172 29.52 8.515 45.01 24.781 25.52 26.801 29.78 49.129 12.65 66.359zm-816.56 324.699c-167.5-12.74-298.71-160.06-298.71-335.394V350.023c0-32.117 24.42-38.691 61.07-38.691s61.07 6.574 61.07 38.691V905.73c0 109.24 79.47 203.04 180.91 213.54 58.24 5.94 114.22-12.29 157.76-51.56 42.74-38.52 67.26-93.909 67.28-151.972.0-16.617-8.14-70.734-45.28-120.968-28.09-37.958-81.3-83.172-175.65-83.172-.51-.012-1.2.0-1.79.0-24.21.0-44.88-1.141-48.86-58.496-2.67-38.594-2.45-55.852 30.89-60.493 59.47-8.25 120.11 3.375 180.2 34.606 102.61 53.383 171.35 154.535 179.43 264.004 7.02 95.078-27.27 187.831-94.09 254.491-67.07 66.89-159.69 101.15-254.23 94.11zM477.48 872.383C357.461 889.613 240.426 857.684 145.102 784.309V1114.5h559.531c19.437.0 33.379 3.5 33.379 60.91.0 56.02-22.571 58.24-37.465 58.24H80.9648c-35.9765.0-55.0117-29.1-55.0117-61.36V630.379c0-28.414 18.0117-38.043 51.5352-44.68 29.3477-5.808 46.3907-2.414 59.2227 11.809l1.351 2.082C197.09 684.672 325.527 767.09 447.605 752.148 593.32 734.32 710.648 618.078 726.695 475.762 736.934 384.953 709.223 297.66 648.719 229.961 588.988 163.121 503.48 124.781 414.156 124.781c-132.328.0-247.984 85.059-296.144 208.508-7.129 18.277-19.1722 31.809-71.3011 12.856C-1.1875 328.73-3.96484 308.574 2.64062 290.32 65.3398 117.672 230.711 1.66016 414.137 1.66016c124.23.0 243.121 53.26174 326.187 146.14084 84.164 94.078 122.391 215.359 108.313 341.504C826.574 686.766 673.727 844.293 477.48 872.383zM2896.61 132.852c-270.27.0-490.16 219.882-490.16 490.148.0 270.277 219.89 490.16 490.16 490.16 270.25.0 490.12-219.883 490.12-490.16.0-270.266-219.87-490.148-490.12-490.148zm0 1113.158c-343.55.0-623.04-279.483-623.04-623.01.0-343.527 279.49-623 623.04-623 343.53.0 623 279.473 623 623s-279.47 623.01-623 623.01zM1548.3 132.852c-270.27.0-490.15 219.882-490.15 490.148.0 270.277 219.88 490.16 490.15 490.16 270.26.0 490.13-219.883 490.13-490.16.0-270.266-219.87-490.148-490.13-490.148zm0 1113.158C1204.76 1246.01 925.262 966.527 925.262 623 925.262 279.473 1204.76.0 1548.3.0c343.53.0 623.01 279.473 623.01 623s-279.48 623.01-623.01 623.01"/></g></g></svg></a><a target=_blank href=https://www.flickr.com/photos/kevinmasson/ rel="noreferrer noopener" title=Flickr><svg fill="currentcolor" width="24" height="24" id="Layer_1" viewBox="0 0 300 300" style="enable-background:new 0 0 300 300"><g id="XMLID_830_"><g id="XMLID_833_"><circle cx="67.57" cy="150" r="67.57"/></g><g id="XMLID_838_"><circle cx="232.43" cy="150" r="67.57"/></g></g></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Writing a ray tracer for the web</h1><div class=post-meta>13 Jan 2020
&nbsp;<span class=separator>·</span>&nbsp;
11 min read&nbsp;<span class=separator>·</span>&nbsp;<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77a5.44 5.44.0 00-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg>
<a href=https://github.com/oktomus/website/blob/master/content/posts/2020/ray-tracer-with-webgl-compute.md rel=nofollow>3 contributors</a></span></div></header><div class=post-content><p>In 2019, <em>Khronos</em> announced and introduced <a href=https://www.khronos.org/registry/webgl/specs/latest/2.0-compute/>WebGL 2.0 Compute</a>, a new specification allowing to use the GPU for more than <a href=https://en.wikipedia.org/wiki/Rasterisation>rasterisation</a>.</p><p>What it really means is that we will be able to use <strong>compute shaders</strong>. These shaders allow to do many more things than the classical <em>vertex, fragment and geometry shader</em> pipeline used for realtime 3D applicaitons.</p><p><em>WebGL 2.0 Compute</em> is still a draft, but some browsers already have implemented it. For example, you can use this API on chrome if you enable some flags:</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-posh data-lang=posh>chrome --use-cmd-decoder=passthrough --use-angle=gl --enable-webgl2-compute-context
</code></pre></div><p>I really wanted to test this new API. So I decided to write <a href=https://oktomus.github.io/webgpu-toy-ray-tracer/>a very simple ray tracer</a>. The goal wasn't to make something pretty or production-ready, but to play with compute shaders and see what can be achieved in a web browser.</p><p>The complete project can be found <a href=https://github.com/oktomus/webgpu-toy-ray-tracer>on github</a>.</p><hr><p>There is another API called <a href=https://gpuweb.github.io/gpuweb/>Web GPU</a> that can be used for the same thing. I will do the same project with this new API and let you know how things go. If you don't want to miss it, follow me on twitter <a href=https://twitter.com/oktomus>@oktomus</a> !</p><h2 id=random-numbers>Random numbers</h2><p>One of the most important thing needed for a raytracer is a good <em>Random Number Generator (RNG)</em>.</p><p>We need a way to generate pseudo-random numbers that is fast, must not have noticeable patterns and behave correctly over time.</p><p>The one I use is directly copied from <a href=https://stackoverflow.com/questions/12964279/whats-the-origin-of-this-glsl-rand-one-liner>somewhere on internet</a> and is seed-based.</p><p>I created a simple demo showing the RNG result, so that you can easily understand how to use the WebGL 2.0 Compute API: <a href=https://oktomus.com/web-experiments/webgl-compute/rng/>demo</a> / <a href=https://github.com/oktomus/web-experiments/tree/master/webgl-compute/rng>code</a>. Here is the shader:</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=color:#cd2828;font-weight:700>#version 310 es</span>

layout (local_size_x = <span style=color:#3677a9>16</span>, local_size_y = <span style=color:#3677a9>16</span>, local_size_z = <span style=color:#3677a9>1</span>) <span style=color:#6ab825;font-weight:700>in</span>;

layout (rgba8, binding = <span style=color:#3677a9>0</span>) writeonly <span style=color:#6ab825;font-weight:700>uniform</span> <span style=color:#6ab825;font-weight:700>highp</span> image2D outputTex;

<span style=color:#6ab825;font-weight:700>uniform</span> <span style=color:#6ab825;font-weight:700>float</span> uSeed;

<span style=color:#6ab825;font-weight:700>float</span> rand(<span style=color:#6ab825;font-weight:700>inout</span> <span style=color:#6ab825;font-weight:700>float</span> seed, <span style=color:#6ab825;font-weight:700>vec2</span> pixel)
{
    <span style=color:#6ab825;font-weight:700>float</span> result = fract(sin(seed / <span style=color:#3677a9>100.0</span>f * dot(pixel, <span style=color:#6ab825;font-weight:700>vec2</span>(<span style=color:#3677a9>12.9898</span>f, <span style=color:#3677a9>78.233</span>f))) * <span style=color:#3677a9>43758.5453</span>f);
    seed += <span style=color:#3677a9>1.0</span>f;
    <span style=color:#6ab825;font-weight:700>return</span> result;
}

<span style=color:#6ab825;font-weight:700>void</span> main() {
    <span style=color:#6ab825;font-weight:700>ivec2</span> storePos = <span style=color:#6ab825;font-weight:700>ivec2</span>(gl_GlobalInvocationID.xy);
    <span style=color:#6ab825;font-weight:700>ivec2</span> imageSize = <span style=color:#6ab825;font-weight:700>ivec2</span>(gl_NumWorkGroups.xy * gl_WorkGroupSize.xy);
    <span style=color:#6ab825;font-weight:700>vec2</span> uv = <span style=color:#6ab825;font-weight:700>vec2</span>(storePos) / <span style=color:#6ab825;font-weight:700>vec2</span>(imageSize);

    <span style=color:#6ab825;font-weight:700>float</span> seed = uSeed;

    <span style=color:#6ab825;font-weight:700>float</span> n = rand(seed, uv);
    <span style=color:#6ab825;font-weight:700>vec4</span> color = <span style=color:#6ab825;font-weight:700>vec4</span>(n, n, n, <span style=color:#3677a9>1.0</span>);

    imageStore(outputTex, storePos, color);
}
</code></pre></div><p>This RNG could be much better. Because the seed is sequential, we can notice some repetitions and patterns. Using a hash of the seed could give better results.</p><p>There is a really nice shadertoy tool to compare different RNGs that you can find <a href=https://www.shadertoy.com/view/wljXDz>here</a>.</p><h2 id=intersections>Intersections</h2><p>Testing for intersection between a ray and a shape is one of the first thing that you implement when making a ray tracer.</p><p>Compared to CPU, implementing intersection on GPU is pretty much the same. However, it is much more complicated to debug GPU code since you can't attach a debugger or print things.</p><p>Also, don't expect your GPU code to fail and throw an error as it does on the CPU. You won't get runtime shader execution errors printed out like <em>Array index out of bounds</em> or such.</p><p>Here is the code I used to test intersection with triangles:</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=color:#6ab825;font-weight:700>struct</span> Ray {
    <span style=color:#6ab825;font-weight:700>vec3</span> origin;
    <span style=color:#6ab825;font-weight:700>vec3</span> direction;
};

<span style=color:#6ab825;font-weight:700>vec3</span> ray_at(Ray r, <span style=color:#6ab825;font-weight:700>float</span> t)
{
    <span style=color:#6ab825;font-weight:700>return</span> r.origin + r.direction * t;
}

<span style=color:#999;font-style:italic>// Test intersection between a ray and a triangle using Möller–Trumbore algorithm.</span>
<span style=color:#6ab825;font-weight:700>bool</span> hit_triangle_mt(Ray r, <span style=color:#6ab825;font-weight:700>vec3</span> v0, <span style=color:#6ab825;font-weight:700>vec3</span> v1, <span style=color:#6ab825;font-weight:700>vec3</span> v2, <span style=color:#6ab825;font-weight:700>out</span> <span style=color:#6ab825;font-weight:700>float</span> t)
{
    <span style=color:#6ab825;font-weight:700>vec3</span> e1 = v1 - v0;
    <span style=color:#6ab825;font-weight:700>vec3</span> e2 = v2 - v0;
    <span style=color:#6ab825;font-weight:700>vec3</span> h = cross(r.direction, e2);

    <span style=color:#6ab825;font-weight:700>float</span> a = dot(e1, h);

    <span style=color:#6ab825;font-weight:700>if</span> (a &lt; EPSILON &amp;&amp; a &gt; EPSILON)
        <span style=color:#6ab825;font-weight:700>return</span> <span style=color:#6ab825;font-weight:700>false</span>;

    <span style=color:#6ab825;font-weight:700>float</span> f = <span style=color:#3677a9>1.0</span> / a;
    <span style=color:#6ab825;font-weight:700>vec3</span> s = r.origin - v0;

    <span style=color:#6ab825;font-weight:700>float</span> u = f * dot(s, h);

    <span style=color:#6ab825;font-weight:700>if</span> (u &lt; <span style=color:#3677a9>0.0</span> || u &gt; <span style=color:#3677a9>1.0</span>)
        <span style=color:#6ab825;font-weight:700>return</span> <span style=color:#6ab825;font-weight:700>false</span>;

    <span style=color:#6ab825;font-weight:700>vec3</span> q = cross(s, e1);
    <span style=color:#6ab825;font-weight:700>float</span> v = f * dot(r.direction, q);

    <span style=color:#6ab825;font-weight:700>if</span> (v &lt; <span style=color:#3677a9>0.0</span> || u + v &gt; <span style=color:#3677a9>1.0</span>)
        <span style=color:#6ab825;font-weight:700>return</span> <span style=color:#6ab825;font-weight:700>false</span>;

    t = f * dot(e2, q);

    <span style=color:#6ab825;font-weight:700>if</span> (t &gt; EPSILON)
    {
        <span style=color:#6ab825;font-weight:700>return</span> <span style=color:#6ab825;font-weight:700>true</span>;
    }

    <span style=color:#6ab825;font-weight:700>return</span> <span style=color:#6ab825;font-weight:700>false</span>;
}
</code></pre></div><p>Note that there is a lot of operations that are already implemented on the GPU like <code>cross</code> and <code>dot</code>.</p><h2 id=shading>Shading</h2><p>As with intersection, shading is also similar on GPU and CPU. Just know that:</p><ul><li>dynamic allocation isn't allowed and</li><li>recursive functions are not a thing.</li></ul><p>Regarding dynamic allocation, it's not really a problem because you should already be doing the same on CPU if you want your ray tracer to be fast.</p><p>For the recursive part, it's a bit annoying at the begining and it can make coding a bit more difficult. But in the end, you can achieve the same thing using a good old <code>while</code> loop with some adjustements in your code.</p><p>To compute the color of a pixel given a camera ray, I use the following code:</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=color:#999;font-style:italic>// Compute the color for a given ray.</span>
<span style=color:#6ab825;font-weight:700>vec3</span> color(Ray r, <span style=color:#6ab825;font-weight:700>inout</span> <span style=color:#6ab825;font-weight:700>float</span> seed, <span style=color:#6ab825;font-weight:700>vec2</span> pixel)
{
    <span style=color:#999;font-style:italic>// Some variables used in the while loop.</span>
    <span style=color:#6ab825;font-weight:700>float</span> t;
    <span style=color:#6ab825;font-weight:700>vec3</span> n;
    <span style=color:#6ab825;font-weight:700>int</span> mesh_index;

    <span style=color:#6ab825;font-weight:700>vec3</span> res = <span style=color:#6ab825;font-weight:700>vec3</span>(<span style=color:#3677a9>0.0</span>);

    <span style=color:#999;font-style:italic>// I hard-coded the light in the code, but we could easily</span>
    <span style=color:#999;font-style:italic>// make them dynamic.</span>
    <span style=color:#6ab825;font-weight:700>int</span> light_mesh_index = <span style=color:#3677a9>0</span>;
    Mesh light = meshes[light_mesh_index];
    <span style=color:#6ab825;font-weight:700>int</span> light_count = light.triangle_count;

    <span style=color:#6ab825;font-weight:700>int</span> depth = <span style=color:#3677a9>0</span>;

    <span style=color:#6ab825;font-weight:700>while</span> (depth &lt; <span style=color:#3677a9>5</span>
        &amp;&amp; hit_world(r, EPSILON, MAX_FLOAT, t, mesh_index, n)
        &amp;&amp; t &gt; <span style=color:#3677a9>0.0</span>)
    {
        Mesh mesh = meshes[mesh_index];
        <span style=color:#6ab825;font-weight:700>vec3</span> surface_normal = n;

        <span style=color:#999;font-style:italic>// Primary ray hit a light, stop (for simplicity sake).</span>
        <span style=color:#6ab825;font-weight:700>if</span> (mesh.emission != <span style=color:#6ab825;font-weight:700>vec3</span>(<span style=color:#3677a9>0.0</span>) &amp;&amp; depth == <span style=color:#3677a9>0</span>)
        {
            <span style=color:#6ab825;font-weight:700>return</span> mesh.emission;
        }

        <span style=color:#6ab825;font-weight:700>vec3</span> hit_point = ray_at(r, t);

        <span style=color:#999;font-style:italic>// Consider hit.</span>
        <span style=color:#6ab825;font-weight:700>if</span> (mesh.emission == <span style=color:#6ab825;font-weight:700>vec3</span>(<span style=color:#3677a9>0.0</span>))
        {
            <span style=color:#6ab825;font-weight:700>float</span> light_pdf = <span style=color:#3677a9>0.0</span>;

            <span style=color:#999;font-style:italic>// Generate a point on the light.</span>
            <span style=color:#6ab825;font-weight:700>vec3</span> light_point = random_point_on_mesh(light, seed, pixel, light_pdf);

            <span style=color:#6ab825;font-weight:700>vec3</span> lh = light_point - hit_point;
            <span style=color:#6ab825;font-weight:700>float</span> dist = length(lh);

            <span style=color:#999;font-style:italic>// Trace a shadow ray.</span>
            Ray shadow_ray;
            shadow_ray.origin = hit_point;
            shadow_ray.direction = normalize(lh);

            <span style=color:#6ab825;font-weight:700>if</span> (!hit_world(shadow_ray, EPSILON, dist, t, mesh_index, n)
                || mesh_index == light_mesh_index)
            {
                <span style=color:#999;font-style:italic>// Direct lighting contribution.</span>
                res += light_pdf * mesh.diffuse * light.emission * abs(dot(surface_normal, shadow_ray.direction));
            }
        }

        <span style=color:#999;font-style:italic>// Bounce.</span>
        <span style=color:#6ab825;font-weight:700>vec2</span> s = rand2(seed, pixel);
        <span style=color:#6ab825;font-weight:700>vec3</span> target = hit_point + n + sample_sphere_uniform(s);
        r.origin = hit_point;
        r.direction = normalize(target - r.origin);

        depth++;
    }

    <span style=color:#6ab825;font-weight:700>return</span> res / <span style=color:#6ab825;font-weight:700>float</span>(depth);
}
</code></pre></div><p>The <code>hit_world</code> method tests the intersection between all triangles and the current ray. To drastically improve performances, and avoid useless triangle-ray tests, we could use an acceleration structure like a <a href=https://en.wikipedia.org/wiki/Bounding_volume_hierarchy>BVH</a>.</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=color:#6ab825;font-weight:700>bool</span> hit_world(Ray r, <span style=color:#6ab825;font-weight:700>float</span> t_min, <span style=color:#6ab825;font-weight:700>float</span> t_max, <span style=color:#6ab825;font-weight:700>inout</span> <span style=color:#6ab825;font-weight:700>float</span> t, <span style=color:#6ab825;font-weight:700>inout</span> <span style=color:#6ab825;font-weight:700>int</span> mesh_index, <span style=color:#6ab825;font-weight:700>inout</span> <span style=color:#6ab825;font-weight:700>vec3</span> n)
{
    <span style=color:#6ab825;font-weight:700>bool</span> does_hit = <span style=color:#6ab825;font-weight:700>false</span>;
    t = <span style=color:#3677a9>0.0</span>;
    <span style=color:#6ab825;font-weight:700>float</span> best_min_t = t_max;

    mesh_index = -<span style=color:#3677a9>1</span>;

    <span style=color:#999;font-style:italic>// Find the closes triangles that the given ray hit.</span>
    <span style=color:#6ab825;font-weight:700>for</span> (<span style=color:#6ab825;font-weight:700>int</span> i = <span style=color:#3677a9>0</span>; i &lt; meshes.length(); ++i)
    {
        Mesh mesh = meshes[i];

        <span style=color:#6ab825;font-weight:700>for</span> (<span style=color:#6ab825;font-weight:700>int</span> j = <span style=color:#3677a9>0</span>; j &lt; mesh.triangle_count * <span style=color:#3677a9>3</span>; j += <span style=color:#3677a9>3</span>)
        {
            <span style=color:#6ab825;font-weight:700>vec3</span> v0 = vertices[triangles[mesh.offset + j]];
            <span style=color:#6ab825;font-weight:700>vec3</span> v1 = vertices[triangles[mesh.offset + j + <span style=color:#3677a9>1</span>]];
            <span style=color:#6ab825;font-weight:700>vec3</span> v2 = vertices[triangles[mesh.offset + j + <span style=color:#3677a9>2</span>]];

            <span style=color:#6ab825;font-weight:700>if</span> (hit_triangle_mt(r, v0, v1, v2, t) &amp;&amp; t &gt;= t_min &amp;&amp; t &lt; t_max &amp;&amp; t &lt; best_min_t)
            {
                best_min_t = t;
                does_hit = <span style=color:#6ab825;font-weight:700>true</span>;
                mesh_index = i;

                <span style=color:#999;font-style:italic>// Compute the normal on the fly.</span>
                n = normalize(cross(v1 - v0, v2 - v0));
            }
        }
    }

    <span style=color:#6ab825;font-weight:700>if</span> (does_hit)
    {
        t = best_min_t;
    }

    <span style=color:#6ab825;font-weight:700>return</span> does_hit;
}
</code></pre></div><h2 id=acessing-to-the-data-on-the-gpu>Acessing to the data on the GPU</h2><p>Using triangles and materials on the GPU was certainly the most tricky part of this project.</p><p>On CPU, we can almost do whatever we want with the memory. It is very easy to create a custom data type, make some lists and start using them to render. Even when writing multi-threaded applications.</p><p>But on GPU, it can be really irritating. The reason is that you need to send your data to the GPU before running the renderer. Which makes sense. But you can't send custom data types, <strong>you can only send bytes</strong> (at least with WebGL).</p><p>So basically, you will have to write the CPU code to correctly pack your scene (triangles, materials, lights) into a buffer, send this buffer (or more), but also write the GPU code for your custom data types and declare the buffers to use them. On top of that, there is some rules to follow for packing your data like padding (you can't just use the binary equivalent of your data on CPU).</p><p>In this project, I used a simple data type to represent each mesh in the scene:</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=color:#999;font-style:italic>// GLSL</span>
<span style=color:#6ab825;font-weight:700>struct</span> Mesh
{
    <span style=color:#6ab825;font-weight:700>int</span> offset;
    <span style=color:#6ab825;font-weight:700>int</span> triangle_count;
    <span style=color:#6ab825;font-weight:700>vec3</span> diffuse;
    <span style=color:#6ab825;font-weight:700>vec3</span> emission;
};
</code></pre></div><p>On the GPU, you can't create an array of array with undefined size. Which means that we can't put the 3D points directly in the Mesh object. So instead, I put all vertices and triangle indexes together in another buffer.</p><p><code>offset</code> represents the index of the first mesh's triangle in the buffer <code>Triangles</code> ahd <code>triangle_count</code> gives the number of triangles.</p><p>The buffer <code>Triangles</code> store 3 vertex index for each triangle and the <code>Vertices</code> buffer store all 3D points.</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=color:#999;font-style:italic>// GLSL</span>
layout (std430, binding = <span style=color:#3677a9>1</span>) readonly buffer Vertices {
    <span style=color:#6ab825;font-weight:700>vec3</span> vertices[];
};

layout (std430, binding = <span style=color:#3677a9>2</span>) readonly buffer Triangles {
    <span style=color:#6ab825;font-weight:700>int</span> triangles[];
};

layout (std430, binding = <span style=color:#3677a9>3</span>) readonly buffer Meshes {
    Mesh meshes[];
};
</code></pre></div><p>On the CPU, the Mesh data type directly contains the vertices and the indexes.</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#999;font-style:italic>// JS
</span><span style=color:#999;font-style:italic></span><span style=color:#6ab825;font-weight:700>export</span> <span style=color:#6ab825;font-weight:700>class</span> Mesh {
    constructor(name, vertices, indexes) {
        <span style=color:#6ab825;font-weight:700>this</span>.name = name;
        <span style=color:#6ab825;font-weight:700>this</span>.vertices = vertices;
        <span style=color:#6ab825;font-weight:700>this</span>.indexes = indexes;
        <span style=color:#6ab825;font-weight:700>this</span>.triangle_count = indexes.length / <span style=color:#3677a9>3</span>;
        <span style=color:#6ab825;font-weight:700>this</span>.vertice_count = vertices.length / <span style=color:#3677a9>3</span>;
        <span style=color:#6ab825;font-weight:700>this</span>.offset = <span style=color:#6ab825;font-weight:700>undefined</span>;
        <span style=color:#6ab825;font-weight:700>this</span>.diffuse_color = glm.vec3(<span style=color:#3677a9>0.4</span>);
        <span style=color:#6ab825;font-weight:700>this</span>.emission = glm.vec3(<span style=color:#3677a9>0.0</span>);
    }
}
</code></pre></div><p>As I said earlier, we need to send data to the GPU before being able to use our renderer. Here I have 3 buffers in my shader so I need to fill those 3 buffers from the CPU. Let's start with the <code>Triangles</code> buffer, which is the easiest as it contains only integers.</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#999;font-style:italic>// JS
</span><span style=color:#999;font-style:italic></span><span style=color:#999;font-style:italic>// Fill the triangles buffer.
</span><span style=color:#999;font-style:italic></span><span style=color:#6ab825;font-weight:700>const</span> triangles_buffer_data = <span style=color:#6ab825;font-weight:700>new</span> <span style=color:#24909d>Array</span>();

<span style=color:#999;font-style:italic>// All indicies of all meshes will end up together.
</span><span style=color:#999;font-style:italic></span><span style=color:#999;font-style:italic>// We need to offset them so that indexes point to the correct vertices.
</span><span style=color:#999;font-style:italic></span><span style=color:#6ab825;font-weight:700>let</span> indexes_offset = <span style=color:#3677a9>0</span>;

<span style=color:#6ab825;font-weight:700>this</span>.meshes.forEach(mesh =&gt; {
    triangles_buffer = triangles_buffer.concat(mesh.indexes.map(i =&gt; i + indexes_offset));
    indexes_offset += mesh.vertice_count;
});

<span style=color:#999;font-style:italic>// Send the triangles buffer to the gpu.
</span><span style=color:#999;font-style:italic></span><span style=color:#6ab825;font-weight:700>const</span> triangles_buffer = <span style=color:#6ab825;font-weight:700>new</span> Int32Array(triangles_buffer_data);
<span style=color:#6ab825;font-weight:700>const</span> triangles_buffer_id = context.createBuffer();
context.bindBuffer(context.SHADER_STORAGE_BUFFER, triangles_buffer_id);
context.bufferData(context.SHADER_STORAGE_BUFFER, triangles_buffer.length * <span style=color:#3677a9>4</span>, context.STATIC_DRAW);
context.bufferSubData(context.SHADER_STORAGE_BUFFER, <span style=color:#3677a9>0</span>, triangles_buffer);
</code></pre></div><p>We can then send the vertices:</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#999;font-style:italic>// JS
</span><span style=color:#999;font-style:italic></span><span style=color:#999;font-style:italic>// Create a buffer containing all vertices.
</span><span style=color:#999;font-style:italic></span><span style=color:#6ab825;font-weight:700>const</span> vertices_buffer = <span style=color:#6ab825;font-weight:700>new</span> Float32Array((total_vertice_count / <span style=color:#3677a9>3</span>) * <span style=color:#3677a9>4</span>);

<span style=color:#6ab825;font-weight:700>let</span> triangles_buffer = <span style=color:#6ab825;font-weight:700>new</span> <span style=color:#24909d>Array</span>();
<span style=color:#6ab825;font-weight:700>let</span> accumulating_triangle_count = <span style=color:#3677a9>0</span>;
<span style=color:#6ab825;font-weight:700>let</span> gpu_i = <span style=color:#3677a9>0</span>;

<span style=color:#6ab825;font-weight:700>this</span>.meshes.forEach(mesh =&gt; {
    <span style=color:#6ab825;font-weight:700>let</span> vertices = mesh.vertices;

    <span style=color:#6ab825;font-weight:700>for</span> (<span style=color:#6ab825;font-weight:700>var</span> i = <span style=color:#3677a9>0</span>; i &lt; vertices.length; i += <span style=color:#3677a9>3</span>)
    {
        vertices_buffer[gpu_i++] = vertices[i];
        vertices_buffer[gpu_i++] = vertices[i + <span style=color:#3677a9>1</span>];
        vertices_buffer[gpu_i++] = vertices[i + <span style=color:#3677a9>2</span>];
        <span style=color:#999;font-style:italic>// We must pad to fit in vec4 -&gt; https://stackoverflow.com/questions/29531237/memory-allocation-with-std430-qualifier.
</span><span style=color:#999;font-style:italic></span>        vertices_buffer[gpu_i++] = <span style=color:#3677a9>0.0</span>;
    }

    mesh.offset = accumulating_triangle_count;
    accumulating_triangle_count += mesh.triangle_count * <span style=color:#3677a9>3</span>;
});

console.assert(gpu_i == vertices_buffer.length, <span style=color:#ed9d13>&#34;GPU buffer does not match vertices count.&#34;</span>, gpu_i, vertices_buffer.length);
console.assert(gpu_i == ((total_vertice_count / <span style=color:#3677a9>3</span>) * <span style=color:#3677a9>4</span>));

<span style=color:#999;font-style:italic>// Send the vertices buffer to the gpu.
</span><span style=color:#999;font-style:italic></span>cons vertices_buffer_id = context.createBuffer();
context.bindBuffer(context.SHADER_STORAGE_BUFFER, vertices_buffer_id);
context.bufferData(context.SHADER_STORAGE_BUFFER, vertices_buffer.length * <span style=color:#3677a9>4</span>, context.STATIC_DRAW);
context.bufferSubData(context.SHADER_STORAGE_BUFFER, <span style=color:#3677a9>0</span>, vertices_buffer);
</code></pre></div><p>Now that we packed all indexes and vertices together, we can send meshes.</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#999;font-style:italic>// JS
</span><span style=color:#999;font-style:italic></span><span style=color:#999;font-style:italic>// Create a buffer containing all meshes.
</span><span style=color:#999;font-style:italic></span><span style=color:#6ab825;font-weight:700>const</span> meshes_buffer = create_meshes_buffer(meshes);

<span style=color:#6ab825;font-weight:700>const</span> meshes_buffer_id = context.createBuffer();
context.bindBuffer(context.SHADER_STORAGE_BUFFER, meshes_buffer_id);
context.bufferData(context.SHADER_STORAGE_BUFFER, meshes_buffer, context.STATIC_DRAW);
context.bindBufferBase(context.SHADER_STORAGE_BUFFER, <span style=color:#3677a9>0</span>, meshes_buffer_id);
</code></pre></div><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#999;font-style:italic>// JS
</span><span style=color:#999;font-style:italic></span><span style=color:#6ab825;font-weight:700>export</span> <span style=color:#6ab825;font-weight:700>function</span> create_meshes_buffer(meshes)
{
    <span style=color:#6ab825;font-weight:700>const</span> buffer = <span style=color:#6ab825;font-weight:700>new</span> ArrayBuffer(meshes.length * Mesh.get_padding());

    <span style=color:#999;font-style:italic>// Create 2 different views to fill the buffer.
</span><span style=color:#999;font-style:italic></span>    <span style=color:#6ab825;font-weight:700>const</span> int32Data = <span style=color:#6ab825;font-weight:700>new</span> Int32Array(buffer);
    <span style=color:#6ab825;font-weight:700>const</span> float32Data = <span style=color:#6ab825;font-weight:700>new</span> Float32Array(buffer);

    <span style=color:#999;font-style:italic>// On the GPU we have:
</span><span style=color:#999;font-style:italic></span>    <span style=color:#999;font-style:italic>// int offset            4 bytes
</span><span style=color:#999;font-style:italic></span>    <span style=color:#999;font-style:italic>// int triangle_count    4 bytes
</span><span style=color:#999;font-style:italic></span>    <span style=color:#999;font-style:italic>//  8 bytes padding
</span><span style=color:#999;font-style:italic></span>    <span style=color:#999;font-style:italic>// vec3 diffuse_color    12 bytes
</span><span style=color:#999;font-style:italic></span>    <span style=color:#999;font-style:italic>//  4 bytes padding
</span><span style=color:#999;font-style:italic></span>    <span style=color:#999;font-style:italic>// vec3 emission         12 bytes
</span><span style=color:#999;font-style:italic></span>    <span style=color:#999;font-style:italic>//  4 bytes padding
</span><span style=color:#999;font-style:italic></span>    <span style=color:#999;font-style:italic>//
</span><span style=color:#999;font-style:italic></span>    <span style=color:#999;font-style:italic>// total: 48  Rounded up to 16 byte padding
</span><span style=color:#999;font-style:italic></span>    <span style=color:#6ab825;font-weight:700>const</span> mesh_padding = <span style=color:#3677a9>48</span>;

    <span style=color:#6ab825;font-weight:700>const</span> four_bytes_padding = mesh_padding / <span style=color:#3677a9>4</span>;

    <span style=color:#6ab825;font-weight:700>for</span> (<span style=color:#6ab825;font-weight:700>let</span> index = <span style=color:#3677a9>0</span>; index &lt; meshes.length; index++) {
        <span style=color:#6ab825;font-weight:700>const</span> element = meshes[index];

        int32Data[four_bytes_padding * index] = element.offset;
        int32Data[four_bytes_padding * index + <span style=color:#3677a9>1</span>] = element.triangle_count;
        <span style=color:#999;font-style:italic>// padding
</span><span style=color:#999;font-style:italic></span>        float32Data[four_bytes_padding * index + <span style=color:#3677a9>4</span>] = element.diffuse_color.x;
        float32Data[four_bytes_padding * index + <span style=color:#3677a9>5</span>] = element.diffuse_color.y;
        float32Data[four_bytes_padding * index + <span style=color:#3677a9>6</span>] = element.diffuse_color.z;
        <span style=color:#999;font-style:italic>// padding
</span><span style=color:#999;font-style:italic></span>        float32Data[four_bytes_padding * index + <span style=color:#3677a9>8</span>] = element.emission.x;
        float32Data[four_bytes_padding * index + <span style=color:#3677a9>9</span>] = element.emission.y;
        float32Data[four_bytes_padding * index + <span style=color:#3677a9>10</span>] = element.emission.z;
    }

    <span style=color:#6ab825;font-weight:700>return</span> buffer;
}
</code></pre></div><p>The buffers are now available on the GPU, but we can't use them as-is in the shader. They need to be bound before the shader runs.</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js>bindBuffer(context, compute_program, buffer_id, layout_name)
{
    <span style=color:#6ab825;font-weight:700>let</span> index = context.getProgramResourceIndex(compute_program, context.SHADER_STORAGE_BLOCK, layout_name);
    <span style=color:#6ab825;font-weight:700>let</span> bind = context.getProgramResource(compute_program, context.SHADER_STORAGE_BLOCK, index, [context.BUFFER_BINDING,])[<span style=color:#3677a9>0</span>];

    context.bindBufferBase(context.SHADER_STORAGE_BUFFER, bind, buffer_id);
}

...

<span style=color:#999;font-style:italic>//=&gt; Bind the buffers to the rendering shader.
</span><span style=color:#999;font-style:italic></span>bindBuffer(context, renderProgram, vertices_buffer_id, <span style=color:#ed9d13>&#34;Vertices&#34;</span>);
bindBuffer(context, renderProgram, triangles_buffer_id, <span style=color:#ed9d13>&#34;Triangles&#34;</span>);
bindBuffer(context, renderProgram, meshes_buffer_id, <span style=color:#ed9d13>&#34;Meshes&#34;</span>);
</code></pre></div><p>If you want to learn more about GPU buffers, you can read about the <a href=https://www.khronos.org/opengl/wiki/Shader_Storage_Buffer_Object>Shader Storage Buffer Object</a>.</p><h2 id=progressive-and-interactive-rendering>Progressive and interactive rendering</h2><p>To keep a realtime frame rate and interactive controls, I used progressive rendering. Many frames are computed over time with low quality settings (<em>samples per pixel = 1</em>) and are accumulated together.</p><p>Like this, the render is instant and if you want a clean sharp render, you just have to wait.</p><p>The code for this is straightforward, you just need 2 textures. One for rendering a frame and one for accumulating and displaying the final result.</p><p>Here is a simple demo of accumulation over time using compute shaders that helped me to implement progressive rendering: <a href=https://oktomus.com/web-experiments/webgl-compute/progressive-steps/>demo</a> / <a href=https://github.com/oktomus/web-experiments/tree/master/webgl-compute/progressive-steps>code</a>.</p><h2 id=render->Render !</h2><p><img src=/2020/cornell_box.png alt="Path traced cornell box from wikipedia"></p><p>If you are interested into rendering, casting some rays and make them bounce, here are some links that will help you getting started:</p><ul><li>Getting started with webgl: <a href=https://webglfundamentals.org/>WebGL fundamentals</a></li><li>Getting started with compute shaders (web): <a href=https://github.com/9ballsyndrome/WebGL_Compute_shader>WebGL Compute shader collection</a></li><li>Implementation and theory of raytracing: <a href=https://github.com/RayTracing/raytracing.github.io>Ray Tracing in One Weekend Book Series</a>, <a href=http://www.pbr-book.org/>Physically Based Rendering book</a>.</li></ul><p>If you have any questions or feedback, feel free to contact me or post a comment. I'm still pretty new to path tracing, any help will be appreciated.</p></div><div class=post-footer><section id=isso-thread></section><script data-isso=https://isso.oktomus.com/ src=https://isso.oktomus.com/js/embed.min.js></script></div></article></main><script type=text/javascript>var _paq=window._paq||[];_paq.push(['trackPageView']);_paq.push(['enableLinkTracking']);(function(){var u="//matomo.oktomus.com/";_paq.push(['setTrackerUrl',u+'matomo.php']);_paq.push(['setSiteId','1']);var d=document,g=d.createElement('script'),s=d.getElementsByTagName('script')[0];g.type='text/javascript';g.async=true;g.defer=true;g.src=u+'matomo.js';s.parentNode.insertBefore(g,s);})();</script></body></html>